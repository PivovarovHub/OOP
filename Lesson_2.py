'''
Объявите класс с именем MediaPlayer с двумя методами:

open(file) - для открытия медиа-файла с именем file 
(создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

Создайте два экземпляра этого класса с именами: media1 и media2. 
Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. 
После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):

"Воспроизведение filemedia1"
"Воспроизведение filemedia2"
'''

class MediaPlayer:

    def open(self, file):
        self.filename = file
    
    def play(self):
        print(f'Воспроизведение {self.filename}')

media1 = MediaPlayer()
media2 = MediaPlayer()

media1.open("filemedia1")
media2.open("filemedia2")
media1.play()
media2.play()

'''
Объявите класс с именем Graph и методами:
set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
draw() - отображение данных (в том же порядке, что и в списке data)

и атрибутом:

LIMIT_Y = [0, 10]

Метод set_data() должен формировать локальное свойство data объекта класса Graph. 
Атрибут data должен ссылаться на переданный в метод список. 
Метод draw() должен выводить на экран список в виде строки из чисел, 
разделенных пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).

Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:

[10, -5, 100, 20, 0, 80, 45, 2, 5, 7]

Затем, вызовите метод draw() через объект graph_1. 
На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. 
Например (вывод без кавычек):

"10 0 2 5 7"
'''

class Graph:
    LIMIT_Y = [0, 10]

    def set_data(self, data):
        self.data = data

    def draw(self):
        a, b = self.LIMIT_Y
        print(*filter(lambda x: a <= x <= b, self.data))


graph_1 = Graph()
graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
graph_1.draw()


'''
Необходимо объявить класс StreamData с методом:

def create(self, fields, lst_values): ...

который бы на входе получал кортеж FIELDS из названий локальных атрибутов 
(передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) 
и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields 
и соответствующими значениями из lst_values.

Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.

'''


class StreamData:
    def create(self, fields, lst_values):
        if len(fields) == len(lst_values):
            self.__dict__ = dict(zip(fields, lst_values))
            return True
        else:
            return False


'''
Необходимо в класс DataBase:

class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')
добавить два метода:

select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;

Каждая запись в списке lst_data должна быть представлена словарем в формате:

{'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}

Например:

{'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
'''

class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')

    def insert(self, data):
        return [self.lst_data.append(dict(zip(self.FIELDS,i.split()))) for i in data]
    def select(self, a, b):
        return [i for i in DataBase.lst_data[a:b+1]]

'''
 Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:

add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует,
то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать);
если связка eng-rus уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'),add('go', 'идти');
remove(self, eng) - для удаления связки по указанному английскому слову;
translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских слов, 
соответствующих переводу английского слова, даже если в списке всего одно слово).

Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, 
т.е. связки хранить локально внутри экземпляров классов класса Translator.

Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:

tree - дерево
car - машина
car - автомобиль
leaf - лист
river - река
go - идти
go - ехать
go - ходить
milk - молоко

Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go. Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:

Вывод в формате: идти ехать ходить'''


